<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="theme-color" content="#c41e3a" />
    <title>Puzzle de No√´l üéÑ</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: radial-gradient(
            ellipse at top,
            #1a4d2e 0%,
            #0d2818 50%,
            #000000 100%
          ),
          url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800"><defs><radialGradient id="glow1"><stop offset="0%%" stop-color="%23ffffff" stop-opacity="0.8"/><stop offset="100%%" stop-color="%23ffffff" stop-opacity="0"/></radialGradient><radialGradient id="glow2"><stop offset="0%%" stop-color="%23ffd700" stop-opacity="0.6"/><stop offset="100%%" stop-color="%23ffd700" stop-opacity="0"/></radialGradient></defs><rect fill="none" width="1200" height="800"/><g opacity="0.9"><circle cx="150" cy="100" r="2" fill="url(%23glow1)"/><circle cx="300" cy="150" r="2.5" fill="url(%23glow1)"/><circle cx="450" cy="80" r="2" fill="url(%23glow1)"/><circle cx="600" cy="120" r="3" fill="url(%23glow2)"/><circle cx="750" cy="90" r="2" fill="url(%23glow1)"/><circle cx="900" cy="140" r="2.5" fill="url(%23glow1)"/><circle cx="1050" cy="110" r="2" fill="url(%23glow1)"/><circle cx="100" cy="300" r="2.5" fill="url(%23glow1)"/><circle cx="250" cy="350" r="2" fill="url(%23glow2)"/><circle cx="400" cy="320" r="2" fill="url(%23glow1)"/><circle cx="550" cy="380" r="2.5" fill="url(%23glow1)"/><circle cx="700" cy="340" r="2" fill="url(%23glow1)"/><circle cx="850" cy="370" r="3" fill="url(%23glow2)"/><circle cx="1000" cy="330" r="2" fill="url(%23glow1)"/><circle cx="1100" cy="360" r="2.5" fill="url(%23glow1)"/><circle cx="180" cy="550" r="2" fill="url(%23glow1)"/><circle cx="320" cy="520" r="2.5" fill="url(%23glow1)"/><circle cx="480" cy="580" r="2" fill="url(%23glow2)"/><circle cx="640" cy="540" r="2" fill="url(%23glow1)"/><circle cx="780" cy="590" r="2.5" fill="url(%23glow1)"/><circle cx="920" cy="560" r="2" fill="url(%23glow1)"/><circle cx="1080" cy="570" r="3" fill="url(%23glow2)"/></g><g opacity="0.15"><path d="M 100 700 Q 150 650 200 700 T 300 700" stroke="%23ffffff" stroke-width="2" fill="none"/><path d="M 400 720 Q 450 670 500 720 T 600 720" stroke="%23ffffff" stroke-width="2" fill="none"/><path d="M 700 710 Q 750 660 800 710 T 900 710" stroke="%23ffffff" stroke-width="2" fill="none"/><path d="M 1000 700 Q 1050 650 1100 700" stroke="%23ffffff" stroke-width="2" fill="none"/></g><g opacity="0.2"><text x="100" y="750" font-family="Arial" font-size="40" fill="%23ff6b6b">üéÑ</text><text x="300" y="770" font-family="Arial" font-size="35" fill="%23ffd700">‚≠ê</text><text x="500" y="760" font-family="Arial" font-size="38" fill="%2366ff66">üéÅ</text><text x="700" y="775" font-family="Arial" font-size="36" fill="%23ffffff">‚ùÑÔ∏è</text><text x="900" y="765" font-family="Arial" font-size="40" fill="%23ff6b6b">üéÑ</text><text x="1100" y="770" font-family="Arial" font-size="35" fill="%23ffd700">‚≠ê</text></g></svg>')
            center/cover;
        background-blend-mode: normal;
        padding: 15px;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(
            circle at 20% 30%,
            rgba(255, 107, 107, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 60%,
            rgba(255, 215, 0, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 50% 80%,
            rgba(102, 255, 102, 0.08) 0%,
            transparent 50%
          );
        pointer-events: none;
        z-index: 1;
      }

      .container {
        position: relative;
        z-index: 10;
        background: rgba(255, 255, 255, 0.98);
        padding: 25px;
        border-radius: 20px;
        box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5);
        text-align: center;
        max-width: 900px;
        width: 100%;
      }

      h1 {
        color: #c41e3a;
        margin-bottom: 20px;
        font-size: clamp(1.8em, 5vw, 2.8em);
        text-shadow: 2px 2px 4px rgba(196, 30, 58, 0.2);
      }

      .step {
        margin: 20px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 15px;
        border-left: 5px solid #c41e3a;
      }

      .step h3 {
        color: #c41e3a;
        margin-bottom: 12px;
        font-size: clamp(1em, 4vw, 1.3em);
      }

      input[type="file"] {
        display: none;
      }

      .btn {
        background: linear-gradient(135deg, #c41e3a 0%, #8b1428 100%);
        color: white;
        padding: 12px 25px;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        font-size: clamp(14px, 3vw, 17px);
        font-weight: bold;
        margin: 8px;
        box-shadow: 0 5px 20px rgba(196, 30, 58, 0.4);
        transition: all 0.3s;
        display: inline-block;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      .btn:active {
        transform: translateY(2px);
        box-shadow: 0 3px 10px rgba(196, 30, 58, 0.4);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .message-input {
        width: 100%;
        max-width: 500px;
        padding: 12px 20px;
        margin: 10px auto;
        border: 2px solid #c41e3a;
        border-radius: 10px;
        font-size: 16px;
        display: block;
        box-sizing: border-box;
      }

      .puzzle-area {
        margin: 25px 0;
        display: none;
      }

      .info-bar {
        display: flex;
        justify-content: space-around;
        margin: 15px 0;
        gap: 10px;
        flex-wrap: wrap;
      }

      .info-item {
        background: linear-gradient(135deg, #c41e3a 0%, #8b1428 100%);
        color: white;
        padding: 12px 20px;
        border-radius: 15px;
        font-size: clamp(0.9em, 3vw, 1.1em);
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(196, 30, 58, 0.3);
        flex: 1;
        min-width: 120px;
      }

      .puzzle-container {
        display: inline-block;
        margin: 15px auto;
        border: 4px solid #c41e3a;
        border-radius: 15px;
        background: white;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        padding: 4px;
        max-width: 100%;
        overflow: hidden;
      }

      .puzzle-grid {
        display: grid;
        gap: 2px;
        background: #2c3e50;
        touch-action: none;
      }

      .puzzle-piece {
        cursor: pointer;
        transition: transform 0.15s ease;
        background-size: cover;
        background-position: center;
        position: relative;
        border-radius: 4px;
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
      }

      .puzzle-piece:not(.empty):active {
        transform: scale(0.97);
      }

      .puzzle-piece.empty {
        background: linear-gradient(
          135deg,
          #34495e 0%,
          #2c3e50 100%
        ) !important;
        cursor: default;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
      }

      .puzzle-piece.can-move {
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        50% {
          box-shadow: 0 0 20px rgba(255, 215, 0, 0.9);
        }
      }

      /* Styles pour le puzzle glisser-d√©poser */
      .puzzle-piece.draggable {
        cursor: grab;
      }

      .puzzle-piece.draggable:active {
        cursor: grabbing;
      }

      .puzzle-piece.dragging {
        opacity: 0.5;
        transform: scale(1.1);
        z-index: 1000;
        box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
      }

      .puzzle-piece.drop-zone {
        background: rgba(255, 215, 0, 0.3) !important;
        border: 2px dashed #ffd700;
      }

      .puzzle-grid.dragdrop-mode {
        position: relative;
      }

      .puzzle-piece.dragdrop-piece {
        position: absolute;
        transition: transform 0.2s ease;
      }

      .share-section {
        display: none;
        margin: 20px 0;
        padding: 20px;
        background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
        border-radius: 15px;
        border: 3px solid #4caf50;
      }

      .share-url {
        width: 100%;
        padding: 12px;
        margin: 15px 0;
        border: 2px solid #4caf50;
        border-radius: 10px;
        font-size: 14px;
        background: white;
        box-sizing: border-box;
        word-break: break-all;
      }

      .victory-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          135deg,
          rgba(196, 30, 58, 0.95),
          rgba(139, 20, 40, 0.95)
        );
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        animation: fadeIn 0.5s;
        padding: 20px;
        box-sizing: border-box;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .victory-content {
        text-align: center;
        animation: zoomIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        max-width: 90%;
        width: 100%;
      }

      @keyframes zoomIn {
        from {
          transform: scale(0.3);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      .victory-title {
        font-size: clamp(2em, 8vw, 4em);
        color: #ffd700;
        text-shadow: 0 0 30px #ffd700, 0 0 60px #ffd700;
        margin: 20px 0;
        animation: glow 2s ease-in-out infinite;
      }

      @keyframes glow {
        0%,
        100% {
          text-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700;
        }
        50% {
          text-shadow: 0 0 40px #ffd700, 0 0 80px #ffd700, 0 0 120px #ffd700;
        }
      }

      .victory-image {
        max-width: 80vw;
        max-height: 40vh;
        border-radius: 20px;
        box-shadow: 0 0 80px rgba(255, 215, 0, 0.9);
        margin: 20px 0;
        border: 5px solid #ffd700;
      }

      .victory-message {
        font-size: clamp(1.2em, 5vw, 2.5em);
        color: white;
        margin: 20px 0;
        text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.5);
        font-weight: bold;
      }

      .victory-stats {
        font-size: clamp(1em, 4vw, 1.5em);
        color: #ffd700;
        margin: 15px 0;
      }

      .firework {
        position: fixed;
        width: 4px;
        height: 4px;
        border-radius: 50%;
        animation: explode 1s ease-out forwards;
        pointer-events: none;
      }

      @keyframes explode {
        0% {
          transform: translate(0, 0);
          opacity: 1;
        }
        100% {
          transform: translate(var(--x), var(--y));
          opacity: 0;
        }
      }

      .preview-image {
        max-width: 200px;
        max-height: 200px;
        border-radius: 10px;
        margin: 15px 0;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      select {
        padding: 10px 20px;
        margin: 10px;
        border: 2px solid #c41e3a;
        border-radius: 10px;
        font-size: 16px;
        cursor: pointer;
        background: white;
        touch-action: manipulation;
      }

      .loading {
        display: none;
        margin: 20px 0;
        color: #c41e3a;
        font-weight: bold;
      }

      @media (max-width: 480px) {
        .container {
          padding: 15px;
        }

        .step {
          padding: 12px;
        }

        .btn {
          padding: 10px 20px;
          margin: 5px;
          font-size: 14px;
        }

        .info-item {
          padding: 10px 15px;
          font-size: 0.9em;
        }

        .puzzle-container {
          padding: 3px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üéÑ Puzzle de No√´l üéÅ</h1>

      <div class="step" id="step1">
        <h3>üì∏ √âtape 1 : Choisissez votre photo</h3>
        <input type="file" id="imageInput" accept="image/*" />
        <label for="imageInput" class="btn">Choisir une photo</label>
        <div id="imagePreview"></div>
        <div class="loading" id="loading">Chargement de l'image...</div>

        <div style="margin-top: 20px">
          <label for="puzzleType">Type de puzzle :</label>
          <select id="puzzleType" style="margin-bottom: 15px">
            <option value="sliding">Puzzle glissant (clic)</option>
            <option value="dragdrop">Puzzle classique (glisser-d√©poser)</option>
          </select>
        </div>
        <div style="margin-top: 20px">
          <label for="gridSize">Difficult√© :</label>
          <select id="gridSize">
            <option value="3">Facile (3√ó3)</option>
            <option value="4" selected>Moyen (4√ó4)</option>
            <option value="5">Difficile (5√ó5)</option>
          </select>
        </div>
      </div>

      <div class="step" id="step2" style="display: none">
        <h3>‚úçÔ∏è √âtape 2 : Personnalisez votre message</h3>
        <input
          type="text"
          id="messageInput"
          class="message-input"
          placeholder="Ex: Joyeux No√´l 2024 ! üéÑ"
          value="üéÑ F√©licitations ! Puzzle r√©solu ! üéÅ"
        />
        <div style="margin-top: 15px">
          <label
            for="passwordInput"
            style="display: block; margin-bottom: 8px; font-weight: bold"
          >
            üîí Mot de passe (optionnel) :
          </label>
          <input
            type="password"
            id="passwordInput"
            class="message-input"
            placeholder="Laissez vide pour un acc√®s libre"
          />
          <p style="font-size: 0.85em; color: #666; margin-top: 5px">
            Si d√©fini, le mot de passe sera requis pour acc√©der au puzzle
          </p>
        </div>
        <button class="btn" id="createPuzzleBtn">Cr√©er le puzzle</button>
      </div>

      <div class="puzzle-area" id="puzzleArea">
        <div class="info-bar">
          <div class="info-item">‚è±Ô∏è Temps: <span id="timer">0:00</span></div>
          <div class="info-item">üî¢ Coups: <span id="moves">0</span></div>
        </div>

        <div class="puzzle-container">
          <div class="puzzle-grid" id="puzzleGrid"></div>
        </div>

        <div style="margin-top: 20px">
          <button class="btn" id="shuffleBtn">üîÄ Nouveau m√©lange</button>
          <button class="btn" id="resetBtn">‚Ü∫ Recommencer</button>
        </div>
        <p
          style="margin-top: 15px; color: #666; font-size: 0.9em"
          id="puzzleHint"
        >
          üí° R√©solvez le puzzle pour d√©couvrir l'image compl√®te !
        </p>
      </div>

      <div class="share-section" id="shareSection">
        <h3>‚úÖ Puzzle cr√©√© avec succ√®s !</h3>
        <p>Partagez ce lien pour que d'autres puissent jouer :</p>
        <input type="text" id="shareUrl" class="share-url" readonly />
        <button class="btn" onclick="copyUrl()">üìã Copier le lien</button>
        <button class="btn" onclick="shareNative()">üì§ Partager</button>
        <button class="btn" onclick="startPlaying()">
          üéÆ Jouer maintenant
        </button>
        <button
          class="btn"
          onclick="returnHome()"
          style="
            margin-top: 10px;
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
          "
        >
          üè† Retour √† l'accueil
        </button>
        <div
          style="
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            font-size: 0.85em;
            color: #555;
          "
        >
          <strong>‚ÑπÔ∏è Informations de s√©curit√© :</strong>
          <ul style="text-align: left; margin: 10px 0; padding-left: 20px">
            <li>
              ‚è∞ Le lien expire automatiquement apr√®s <strong>24 heures</strong>
            </li>
            <li>
              üì¶ L'image est <strong>encod√©e dans l'URL</strong> (pas de
              stockage serveur)
            </li>
            <li>
              üîí <strong>Quiconque a le lien</strong> peut voir l'image -
              partagez avec pr√©caution
            </li>
            <li>
              üóëÔ∏è Pour supprimer : le lien devient inutilisable apr√®s expiration
            </li>
          </ul>
        </div>
      </div>
    </div>

    <div class="victory-overlay" id="victoryOverlay">
      <div class="victory-content">
        <div class="victory-title">‚ú® üéâ BRAVO ! üéâ ‚ú®</div>
        <img id="victoryImage" class="victory-image" />
        <div class="victory-message" id="victoryMessage"></div>
        <div class="victory-stats" id="victoryStats"></div>
        <button
          class="btn"
          onclick="location.reload()"
          style="font-size: 1.2em; margin-top: 20px"
        >
          üîÑ Nouveau puzzle
        </button>
      </div>
    </div>

    <div class="victory-overlay" id="passwordModal" style="display: none">
      <div class="victory-content" style="max-width: 400px">
        <h2 style="color: #c41e3a; margin-bottom: 20px">
          üîí Mot de passe requis
        </h2>
        <p style="color: white; margin-bottom: 20px">
          Ce puzzle est prot√©g√© par un mot de passe. Veuillez le saisir pour
          continuer.
        </p>
        <input
          type="password"
          id="passwordCheckInput"
          class="message-input"
          placeholder="Entrez le mot de passe"
          style="width: 100%; margin-bottom: 15px"
          onkeypress="if(event.key === 'Enter') checkPassword()"
        />
        <div
          id="passwordError"
          style="
            color: #ffd700;
            margin-bottom: 15px;
            display: none;
            font-weight: bold;
          "
        >
          ‚ùå Mot de passe incorrect
        </div>
        <button class="btn" onclick="checkPassword()" style="width: 100%">
          üîì Acc√©der au puzzle
        </button>
      </div>
    </div>

    <script>
      let gridSize = 4;
      let puzzleType = "sliding"; // "sliding" ou "dragdrop"
      let tiles = [];
      let emptyIndex;
      let imageData = null;
      let moves = 0;
      let timer = 0;
      let timerInterval = null;
      let customMessage = "";
      let startTime = null;
      let touchStartX = null;
      let touchStartY = null;
      let draggedElement = null; // Pour le drag and drop
      let shareUrlComplete = null; // URL compl√®te pour le partage (√©vite la troncature du champ input)

      const imageInput = document.getElementById("imageInput");
      const puzzleGrid = document.getElementById("puzzleGrid");
      const step1 = document.getElementById("step1");
      const step2 = document.getElementById("step2");
      const puzzleArea = document.getElementById("puzzleArea");
      const shareSection = document.getElementById("shareSection");
      const loading = document.getElementById("loading");
      let storedPasswordHash = null; // Hash du mot de passe stock√© dans l'URL

      // Nettoyer les anciennes entr√©es localStorage expir√©es
      function cleanupExpiredPuzzles() {
        try {
          const keys = Object.keys(localStorage);
          let cleaned = 0;
          for (let key of keys) {
            if (key.startsWith("puzzle_")) {
              try {
                const stored = JSON.parse(localStorage.getItem(key));
                if (stored && stored.expires && stored.expires < Date.now()) {
                  localStorage.removeItem(key);
                  cleaned++;
                }
              } catch (err) {
                // Si erreur de parsing, supprimer l'entr√©e
                localStorage.removeItem(key);
                cleaned++;
              }
            }
          }
          if (cleaned > 0) {
            console.log(
              `Nettoyage: ${cleaned} puzzle(s) expir√©(s) supprim√©(s)`
            );
          }
        } catch (e) {
          console.error("Erreur lors du nettoyage:", e);
        }
      }

      // Nettoyer au chargement de la page
      cleanupExpiredPuzzles();

      // Hasher un mot de passe (hash simple mais efficace)
      async function hashPassword(password) {
        if (!password) return null;
        const encoder = new TextEncoder();
        const data = encoder.encode(password);
        const hashBuffer = await crypto.subtle.digest("SHA-256", data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
      }

      // V√©rifier le mot de passe
      async function checkPassword() {
        const input = document.getElementById("passwordCheckInput");
        const enteredPassword = input.value;
        const errorDiv = document.getElementById("passwordError");

        if (!enteredPassword) {
          errorDiv.textContent = "‚ùå Veuillez entrer un mot de passe";
          errorDiv.style.display = "block";
          return;
        }

        const enteredHash = await hashPassword(enteredPassword);

        if (enteredHash === storedPasswordHash) {
          // Mot de passe correct
          document.getElementById("passwordModal").style.display = "none";
          // Continuer le chargement du puzzle
          loadPuzzleFromStoredData();
        } else {
          // Mot de passe incorrect
          errorDiv.textContent = "‚ùå Mot de passe incorrect";
          errorDiv.style.display = "block";
          input.value = "";
          input.focus();
        }
      }

      // Variables pour stocker temporairement les donn√©es du puzzle en attente de mot de passe
      let pendingImageData = null;
      let pendingMessage = null;
      let pendingGridSize = 4;
      let pendingPuzzleType = "sliding";

      // Charger le puzzle apr√®s v√©rification du mot de passe
      function loadPuzzleFromStoredData() {
        if (!pendingImageData) return;

        imageData = pendingImageData;
        customMessage = pendingMessage;
        gridSize = pendingGridSize;
        puzzleType = pendingPuzzleType;

        // Cacher toutes les √©tapes de cr√©ation
        step1.style.display = "none";
        step2.style.display = "none";
        shareSection.style.display = "none";

        // Afficher directement le puzzle
        puzzleArea.style.display = "block";

        // Changer le titre
        document.querySelector("h1").textContent = "üéÑ Puzzle Partag√© üéÅ";

        // D√©marrer le puzzle
        setTimeout(() => {
          if (imageData) {
            initPuzzle();
            startTimer();
          }
        }, 100);
      }

      // Compresser l'image pour r√©duire la taille de l'URL (compression maximale)
      function compressImage(file, maxWidth = 500, quality = 0.5) {
        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              const canvas = document.createElement("canvas");
              let width = img.width;
              let height = img.height;

              if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
              }

              canvas.width = width;
              canvas.height = height;

              const ctx = canvas.getContext("2d");
              ctx.drawImage(img, 0, 0, width, height);

              // Compression agressive pour r√©duire la taille de l'URL
              let finalQuality = quality;
              if (width * height > 200000) {
                finalQuality = 0.4;
              } else if (width * height > 100000) {
                finalQuality = 0.45;
              }

              const compressed = canvas.toDataURL("image/jpeg", finalQuality);
              resolve(compressed);
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        });
      }

      // Charger depuis URL (nouveau format avec ID court ou ancien format pour compatibilit√©)
      function loadFromURL() {
        try {
          // Essayer d'abord le hash (#), puis les query params pour compatibilit√©
          let hashData = window.location.hash.substring(1);
          let urlParams = window.location.search;

          console.log(
            "loadFromURL - hashData:",
            hashData ? hashData.substring(0, 50) : "vide"
          );

          let imgData = null;
          let msg = null;
          let size = null;
          let timestamp = null;
          let passwordHash = null;
          let type = null;
          let puzzleId = null;

          // V√©rifier si c'est le nouveau format avec ID court (#id=xxxxx)
          if (hashData && hashData.startsWith("id=")) {
            puzzleId = hashData.substring(3);
            console.log("Format ID court d√©tect√©, ID:", puzzleId);

            // Essayer de charger depuis localStorage d'abord
            const storageKey = `puzzle_${puzzleId}`;
            let loaded = false;

            try {
              const stored = localStorage.getItem(storageKey);
              if (stored) {
                const puzzleData = JSON.parse(stored);

                // V√©rifier l'expiration
                if (puzzleData.expires && puzzleData.expires < Date.now()) {
                  console.log("Les donn√©es ont expir√©");
                  localStorage.removeItem(storageKey);
                  showExpiredMessage();
                  return;
                }

                // Extraire les donn√©es
                imgData = puzzleData.img;
                msg = puzzleData.msg;
                size = puzzleData.size;
                type = puzzleData.type;
                timestamp = puzzleData.t;
                passwordHash = puzzleData.p;

                loaded = true;
                console.log("‚úÖ Donn√©es charg√©es depuis localStorage:", {
                  hasImg: !!imgData,
                  hasMsg: !!msg,
                  size: size,
                  type: type,
                });
              }
            } catch (e) {
              console.warn("Erreur lors du chargement depuis localStorage:", e);
            }

            // Si pas trouv√© localement, essayer de charger depuis jsonstorage.net
            if (!loaded) {
              loading.style.display = "block";
              loading.textContent = "Chargement du puzzle...";

              fetch(`https://jsonstorage.net/api/items/${puzzleId}`, {
                method: "GET",
              })
                .then((response) => {
                  if (!response.ok) throw new Error("Puzzle introuvable");
                  return response.json();
                })
                .then((data) => {
                  // V√©rifier l'expiration
                  if (data.expires && data.expires < Date.now()) {
                    showExpiredMessage();
                    loading.style.display = "none";
                    return;
                  }

                  // Extraire les donn√©es
                  imgData = data.img;
                  msg = data.msg;
                  size = data.size;
                  type = data.type;
                  timestamp = data.t;
                  passwordHash = data.p;

                  // Sauvegarder localement pour la prochaine fois
                  try {
                    localStorage.setItem(storageKey, JSON.stringify(data));
                  } catch (e) {
                    console.warn("Impossible de sauvegarder localement:", e);
                  }

                  console.log("‚úÖ Donn√©es charg√©es depuis le serveur:", {
                    hasImg: !!imgData,
                    hasMsg: !!msg,
                    size: size,
                    type: type,
                  });

                  loading.style.display = "none";
                  loaded = true;
                })
                .catch((error) => {
                  console.error(
                    "Erreur lors du chargement depuis le serveur:",
                    error
                  );
                  loading.style.display = "none";

                  // Afficher un message d'erreur
                  step1.style.display = "none";
                  step2.style.display = "none";
                  puzzleArea.style.display = "none";
                  shareSection.style.display = "none";

                  const errorDiv = document.createElement("div");
                  errorDiv.className = "step";
                  errorDiv.style.background =
                    "linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)";
                  errorDiv.style.color = "white";
                  errorDiv.style.borderLeft = "5px solid #c41e3a";
                  errorDiv.innerHTML = `
                  <h3>‚ùå Puzzle introuvable</h3>
                  <p>Le puzzle avec l'ID "${puzzleId}" n'a pas √©t√© trouv√©.</p>
                  <p style="font-size: 0.9em; margin-top: 10px;">Le lien peut avoir expir√© (24h) ou avoir √©t√© supprim√©.</p>
                  <button class="btn" onclick="returnHome()" style="background: white; color: #c41e3a; margin-top: 15px;">
                    üè† Cr√©er un nouveau puzzle
                  </button>
                `;
                  document.querySelector(".container").appendChild(errorDiv);
                })
                .finally(() => {
                  // Continuer le traitement apr√®s le chargement (m√™me si √©chec)
                  if (imgData && msg) {
                    processLoadedPuzzleData(
                      imgData,
                      msg,
                      size,
                      type,
                      timestamp,
                      passwordHash
                    );
                  }
                });

              // Si charg√© depuis localStorage, traiter directement
              if (loaded) {
                processLoadedPuzzleData(
                  imgData,
                  msg,
                  size,
                  type,
                  timestamp,
                  passwordHash
                );
                return; // Sortir car on a d√©j√† trait√©
              } else {
                // Attendre le chargement asynchrone (la fonction processLoadedPuzzleData sera appel√©e dans .finally())
                return;
              }
            }
          }

          // Fonction pour traiter les donn√©es charg√©es (utilis√©e pour le nouveau format avec ID)
          function processLoadedPuzzleData(
            imgData,
            msg,
            size,
            type,
            timestamp,
            passwordHash
          ) {
            // V√©rifier l'expiration
            if (timestamp) {
              const linkTimestamp = parseInt(timestamp);
              const now = Date.now();
              const expirationTime = 24 * 60 * 60 * 1000; // 24 heures

              if (now - linkTimestamp > expirationTime) {
                showExpiredMessage();
                return;
              }
            }

            // Stocker temporairement les donn√©es
            try {
              pendingImageData = imgData;
              pendingMessage = msg;
              pendingGridSize = size ? parseInt(size) : 4;
              pendingPuzzleType = type || "sliding";

              // V√©rifier que l'image est valide
              if (
                !pendingImageData ||
                !pendingImageData.startsWith("data:image")
              ) {
                console.error("Format d'image invalide ou manquant");
                return;
              }

              // V√©rifier si un mot de passe est requis
              if (passwordHash) {
                storedPasswordHash = passwordHash;
                document.getElementById("passwordModal").style.display = "flex";
                document.getElementById("passwordCheckInput").focus();
                return;
              }

              // Pas de mot de passe, charger directement
              console.log("Chargement du puzzle partag√©...");
              imageData = pendingImageData;
              customMessage = pendingMessage;
              gridSize = pendingGridSize;
              puzzleType = pendingPuzzleType;

              // Cacher toutes les √©tapes de cr√©ation
              step1.style.display = "none";
              step2.style.display = "none";
              shareSection.style.display = "none";

              // Afficher directement le puzzle
              puzzleArea.style.display = "block";

              // Changer le titre
              document.querySelector("h1").textContent = "üéÑ Puzzle Partag√© üéÅ";

              // D√©marrer le puzzle
              setTimeout(() => {
                if (imageData) {
                  initPuzzle();
                  startTimer();
                }
              }, 100);
            } catch (error) {
              console.error(
                "Erreur lors du chargement du puzzle partag√©:",
                error
              );
            }
          }

          // Si on n'a pas encore charg√© les donn√©es (ancien format ou format avec donn√©es dans l'URL)
          if (
            !imgData &&
            hashData &&
            hashData.length > 10 &&
            !hashData.startsWith("id=")
          ) {
            // Fonction de parsing robuste bas√©e sur l'ordre fixe des param√®tres (ANCIEN FORMAT)
            // L'ordre attendu: i=...&m=...&s=...&y=...&t=...&p=...
            function parseHashData(hash) {
              const result = {};

              // Trouver les positions de chaque param√®tre dans l'ordre
              // On cherche &m= (pas juste m=) pour √©viter les faux positifs dans l'image encod√©e
              const iIndex = hash.indexOf("i=");
              const mIndex = hash.indexOf("&m=");
              const sIndex = hash.indexOf("&s=");
              const yIndex = hash.indexOf("&y=");
              const tIndex = hash.indexOf("&t=");
              const pIndex = hash.indexOf("&p=");

              // Extraire l'image (i=... jusqu'√† &m=)
              // L'image commence toujours par "i=" et se termine par "&m="
              if (iIndex === 0 && mIndex !== -1) {
                result.img = hash.substring(2, mIndex);
                console.log(
                  "Image extraite: d√©but √†",
                  mIndex,
                  "longueur:",
                  result.img.length
                );
              } else if (iIndex === 0 && mIndex === -1) {
                // Si &m= n'est pas trouv√©, l'URL est probablement tronqu√©e
                console.warn("&m= non trouv√©, URL peut √™tre tronqu√©e");
              }

              // Extraire le message (&m=... jusqu'√† &s=)
              if (mIndex !== -1 && sIndex !== -1) {
                result.msg = hash.substring(mIndex + 3, sIndex);
                console.log(
                  "Message extrait: de",
                  mIndex + 3,
                  "√†",
                  sIndex,
                  "longueur:",
                  result.msg.length
                );
              }

              // Extraire size (&s=... jusqu'√† &y= ou &t=)
              if (sIndex !== -1) {
                const endIndex =
                  yIndex !== -1 ? yIndex : tIndex !== -1 ? tIndex : hash.length;
                result.size = hash.substring(sIndex + 3, endIndex);
              }

              // Extraire type (&y=... jusqu'√† &t=)
              if (yIndex !== -1 && tIndex !== -1) {
                result.type = hash.substring(yIndex + 3, tIndex);
              } else if (yIndex !== -1) {
                // Si &t= n'est pas trouv√© mais &y= oui, prendre jusqu'√† la fin
                result.type = hash.substring(yIndex + 3);
              }

              // Extraire timestamp (&t=... jusqu'√† &p= ou fin)
              if (tIndex !== -1) {
                const endIndex = pIndex !== -1 ? pIndex : hash.length;
                result.timestamp = hash.substring(tIndex + 3, endIndex);
              }

              // Extraire password (&p=... jusqu'√† la fin)
              if (pIndex !== -1) {
                result.password = hash.substring(pIndex + 3);
              }

              return result;
            }

            try {
              // Essayer d'abord avec URLSearchParams
              const hashParams = new URLSearchParams(hashData);
              imgData = hashParams.get("i") || hashParams.get("img");
              msg = hashParams.get("m") || hashParams.get("msg");
              size = hashParams.get("s") || hashParams.get("size");
              timestamp = hashParams.get("t");
              passwordHash = hashParams.get("p");
              type = hashParams.get("y") || hashParams.get("type");

              console.log("URLSearchParams r√©sultat:", {
                hasImg: !!imgData,
                imgLength: imgData ? imgData.length : 0,
                hasMsg: !!msg,
              });
            } catch (e) {
              console.warn(
                "URLSearchParams a √©chou√©, utilisation du parsing manuel:",
                e
              );
            }

            // Si URLSearchParams n'a pas fonctionn√© ou n'a pas retourn√© les donn√©es, utiliser le parsing manuel
            if (!imgData || !msg) {
              console.log(
                "Utilisation du parsing manuel bas√© sur l'ordre des param√®tres"
              );
              console.log("hashData d√©but:", hashData.substring(0, 100));
              console.log("hashData contient '&m=':", hashData.includes("&m="));
              console.log("hashData contient '&s=':", hashData.includes("&s="));

              const parsed = parseHashData(hashData);
              console.log("R√©sultat du parsing manuel:", {
                hasImg: !!parsed.img,
                imgLength: parsed.img ? parsed.img.length : 0,
                hasMsg: !!parsed.msg,
                msgLength: parsed.msg ? parsed.msg.length : 0,
              });

              if (parsed.img && !imgData) {
                imgData = parsed.img;
                console.log(
                  "‚úÖ Image extraite via parsing manuel, longueur:",
                  imgData.length
                );
                console.log("Image d√©but:", imgData.substring(0, 50));
              } else if (!imgData) {
                console.error("‚ùå Impossible d'extraire l'image du hash");
              }

              if (parsed.msg && !msg) {
                msg = parsed.msg;
                console.log(
                  "‚úÖ Message extrait via parsing manuel, longueur:",
                  msg.length
                );
              } else if (!msg) {
                console.error("‚ùå Impossible d'extraire le message du hash");
              }

              if (parsed.size && !size) {
                size = parsed.size;
              }

              if (parsed.type && !type) {
                type = parsed.type;
              }

              if (parsed.timestamp && !timestamp) {
                timestamp = parsed.timestamp;
              }

              if (parsed.password && !passwordHash) {
                passwordHash = parsed.password;
              }
            }

            console.log("loadFromURL - Param√®tres finaux extraits:", {
              hasImg: !!imgData,
              imgLength: imgData ? imgData.length : 0,
              hasMsg: !!msg,
              msgLength: msg ? msg.length : 0,
              size: size,
              type: type,
            });
          }

          // Sinon, essayer les query params
          if ((!imgData || !msg) && urlParams && urlParams.length > 10) {
            const params = new URLSearchParams(urlParams);
            // Support des param√®tres courts (nouveau format) et longs (ancien format pour compatibilit√©)
            imgData = imgData || params.get("i") || params.get("img");
            msg = msg || params.get("m") || params.get("msg");
            size = size || params.get("s") || params.get("size");
            timestamp = timestamp || params.get("t");
            passwordHash = passwordHash || params.get("p");
            type = type || params.get("y") || params.get("type");

            console.log("loadFromURL - Param√®tres extraits des query params:", {
              hasImg: !!imgData,
              hasMsg: !!msg,
            });
          }

          // V√©rifier l'expiration (24 heures = 86400000 ms)
          if (timestamp) {
            const linkTimestamp = parseInt(timestamp);
            const now = Date.now();
            const expirationTime = 24 * 60 * 60 * 1000; // 24 heures

            if (now - linkTimestamp > expirationTime) {
              // Le lien a expir√©
              console.log("Lien expir√©");
              showExpiredMessage();
              return;
            }
          }

          // V√©rifier si on a les param√®tres n√©cessaires
          if (imgData && msg) {
            // C'est un puzzle partag√©
            try {
              // Stocker temporairement les donn√©es
              try {
                pendingImageData = decodeURIComponent(imgData);
                pendingMessage = decodeURIComponent(msg);
                pendingGridSize = size ? parseInt(size) : 4;
                pendingPuzzleType = type || "sliding"; // Par d√©faut, puzzle glissant

                console.log("loadFromURL - Donn√©es d√©cod√©es:", {
                  imageStart: pendingImageData
                    ? pendingImageData.substring(0, 50)
                    : null,
                  message: pendingMessage,
                  gridSize: pendingGridSize,
                  puzzleType: pendingPuzzleType,
                });

                // V√©rifier que l'image est valide
                if (
                  !pendingImageData ||
                  !pendingImageData.startsWith("data:image")
                ) {
                  console.error(
                    "Format d'image invalide ou manquant. Image start:",
                    pendingImageData
                      ? pendingImageData.substring(0, 100)
                      : "null"
                  );
                  return;
                }
              } catch (decodeError) {
                console.error(
                  "Erreur lors du d√©codage des param√®tres:",
                  decodeError
                );
                return;
              }

              // V√©rifier si un mot de passe est requis
              if (passwordHash) {
                storedPasswordHash = passwordHash;
                // Afficher le modal de mot de passe
                document.getElementById("passwordModal").style.display = "flex";
                document.getElementById("passwordCheckInput").focus();
                return;
              }

              // Pas de mot de passe, charger directement
              console.log("Chargement du puzzle partag√©...");
              imageData = pendingImageData;
              customMessage = pendingMessage;
              gridSize = pendingGridSize;
              puzzleType = pendingPuzzleType;

              // Cacher toutes les √©tapes de cr√©ation
              step1.style.display = "none";
              step2.style.display = "none";
              shareSection.style.display = "none";

              // Afficher directement le puzzle
              puzzleArea.style.display = "block";

              // Changer le titre pour indiquer qu'on joue un puzzle partag√©
              document.querySelector("h1").textContent = "üéÑ Puzzle Partag√© üéÅ";

              // D√©marrer le puzzle automatiquement apr√®s un court d√©lai pour s'assurer que tout est charg√©
              setTimeout(() => {
                if (imageData) {
                  initPuzzle();
                  startTimer();
                }
              }, 100);
            } catch (error) {
              console.error(
                "Erreur lors du chargement du puzzle partag√©:",
                error
              );
              // En cas d'erreur, afficher le formulaire normal
            }
          } else {
            console.log(
              "loadFromURL - Pas de donn√©es de puzzle trouv√©es dans l'URL"
            );
            console.log(
              "hashData:",
              hashData ? hashData.substring(0, 200) : "vide"
            );
            console.log(
              "urlParams:",
              urlParams ? urlParams.substring(0, 200) : "vide"
            );

            // Si on a un hash mais pas de donn√©es valides, c'est peut-√™tre une URL tronqu√©e
            if (hashData && hashData.length > 10 && (!imgData || !msg)) {
              console.warn(
                "‚ö†Ô∏è URL d√©tect√©e mais donn√©es incompl√®tes - l'URL a peut-√™tre √©t√© tronqu√©e"
              );
              // Afficher un message d'aide √† l'utilisateur
              const container = document.querySelector(".container");
              if (container && !document.getElementById("urlErrorMsg")) {
                const errorMsg = document.createElement("div");
                errorMsg.id = "urlErrorMsg";
                errorMsg.className = "step";
                errorMsg.style.background =
                  "linear-gradient(135deg, #ff9800 0%, #f57c00 100%)";
                errorMsg.style.color = "white";
                errorMsg.style.borderLeft = "5px solid #e65100";
                errorMsg.innerHTML = `
                  <h3>‚ö†Ô∏è Lien incomplet</h3>
                  <p>Le lien partag√© semble incomplet ou tronqu√©. L'image n'a pas pu √™tre charg√©e.</p>
                  <p style="font-size: 0.9em; margin-top: 10px;">Veuillez demander un nouveau lien √† la personne qui a cr√©√© le puzzle.</p>
                  <button class="btn" onclick="returnHome()" style="background: white; color: #e65100; margin-top: 15px;">
                    üè† Cr√©er un nouveau puzzle
                  </button>
                `;
                container.insertBefore(errorMsg, container.firstChild);
              }
            }
          }
        } catch (error) {
          console.error("Erreur lors de la lecture des param√®tres URL:", error);
        }
      }

      // Afficher un message d'expiration
      function showExpiredMessage() {
        step1.style.display = "none";
        step2.style.display = "none";
        puzzleArea.style.display = "none";
        shareSection.style.display = "none";

        const expiredDiv = document.createElement("div");
        expiredDiv.className = "step";
        expiredDiv.style.background =
          "linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)";
        expiredDiv.style.color = "white";
        expiredDiv.style.borderLeft = "5px solid #c41e3a";
        expiredDiv.innerHTML = `
          <h3>‚è∞ Lien expir√©</h3>
          <p>Ce lien de puzzle a expir√© (valable 24 heures).</p>
          <p>Demandez un nouveau lien √† la personne qui a cr√©√© le puzzle.</p>
          <button class="btn" onclick="returnHome()" style="background: white; color: #c41e3a; margin-top: 15px;">
            üè† Cr√©er un nouveau puzzle
          </button>
        `;
        document.querySelector(".container").appendChild(expiredDiv);
      }

      // Charger au d√©marrage
      window.addEventListener("load", loadFromURL);
      // Aussi essayer imm√©diatement au cas o√π le DOM serait d√©j√† charg√©
      if (
        document.readyState === "complete" ||
        document.readyState === "interactive"
      ) {
        setTimeout(loadFromURL, 0);
      }

      imageInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (file) {
          loading.style.display = "block";
          try {
            imageData = await compressImage(file);

            const preview = document.getElementById("imagePreview");
            preview.innerHTML = `<img src="${imageData}" class="preview-image">`;

            step2.style.display = "block";
          } catch (error) {
            alert("Erreur lors du chargement de l'image");
          } finally {
            loading.style.display = "none";
          }
        }
      });

      document
        .getElementById("createPuzzleBtn")
        .addEventListener("click", async () => {
          customMessage =
            document.getElementById("messageInput").value ||
            "üéÑ F√©licitations ! üéÅ";
          gridSize = parseInt(document.getElementById("gridSize").value);
          puzzleType = document.getElementById("puzzleType").value;

          // R√©cup√©rer et hasher le mot de passe si fourni
          const passwordInput = document.getElementById("passwordInput");
          const password = passwordInput.value.trim();
          const passwordHash = password ? await hashPassword(password) : null;

          // Construire l'URL avec hash (#) pour √©viter les limites de longueur
          let baseUrl = window.location.origin;
          const pathname = window.location.pathname || "/";
          baseUrl += pathname.endsWith("/") ? pathname.slice(0, -1) : pathname;

          // Ajouter un timestamp pour l'expiration (24 heures)
          const timestamp = Date.now();

          // G√©n√©rer un ID court unique (8 caract√®res al√©atoires)
          function generateShortId() {
            const chars =
              "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            let id = "";
            for (let i = 0; i < 8; i++) {
              id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return id;
          }

          const puzzleId = generateShortId();

          // Pr√©parer les donn√©es √† stocker
          const puzzleData = {
            img: imageData,
            msg: customMessage,
            size: gridSize,
            type: puzzleType,
            t: timestamp,
            p: passwordHash,
            expires: timestamp + 24 * 60 * 60 * 1000, // 24 heures
          };

          // Stocker dans localStorage (backup local) ET essayer de stocker en ligne
          const storageKey = `puzzle_${puzzleId}`;
          try {
            localStorage.setItem(storageKey, JSON.stringify(puzzleData));
            console.log(
              "‚úÖ Donn√©es stock√©es dans localStorage avec l'ID:",
              puzzleId
            );
          } catch (e) {
            console.warn("Impossible de stocker dans localStorage:", e);
          }

          // Essayer de stocker en ligne avec jsonstorage.net (gratuit, pas besoin de cl√© API)
          loading.style.display = "block";
          loading.textContent = "Cr√©ation du lien de partage...";

          fetch(`https://jsonstorage.net/api/items/${puzzleId}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(puzzleData),
          })
            .then((response) => response.json())
            .then((data) => {
              console.log("‚úÖ Donn√©es stock√©es en ligne avec succ√®s");
              loading.style.display = "none";
            })
            .catch((error) => {
              console.warn(
                "‚ö†Ô∏è Impossible de stocker en ligne (mode hors ligne ou erreur r√©seau):",
                error
              );
              console.log("Utilisation du stockage local uniquement");
              loading.style.display = "none";
              // On continue quand m√™me avec localStorage
            });

          // Cr√©er une URL courte avec juste l'ID
          let url = `${baseUrl}#id=${puzzleId}`;

          console.log(
            "‚úÖ URL courte g√©n√©r√©e (longueur: " +
              url.length +
              " caract√®res, ID: " +
              puzzleId +
              ")"
          );

          // Stocker l'URL compl√®te dans une variable globale
          shareUrlComplete = url;

          // Afficher l'URL dans le champ
          const urlInput = document.getElementById("shareUrl");
          urlInput.value = url;

          shareSection.style.display = "block";
          step1.style.display = "none";
          step2.style.display = "none";
        });

      function startPlaying() {
        shareSection.style.display = "none";
        puzzleArea.style.display = "block";
        // Remettre le titre original si on joue depuis la cr√©ation
        document.querySelector("h1").textContent = "üéÑ Puzzle de No√´l üéÅ";
        initPuzzle();
        startTimer();
      }

      function initPuzzle() {
        // Mettre √† jour le message d'aide selon le type
        const hintElement = document.getElementById("puzzleHint");
        if (puzzleType === "dragdrop") {
          if (hintElement) {
            hintElement.textContent =
              "üí° Glissez-d√©posez les pi√®ces pour reconstituer l'image !";
          }
          initPuzzleDragDrop();
        } else {
          if (hintElement) {
            hintElement.textContent =
              "üí° Cliquez sur les pi√®ces pour les d√©placer vers la case vide !";
          }
          initPuzzleSliding();
        }
      }

      // Puzzle glissant (type original)
      function initPuzzleSliding() {
        moves = 0;
        document.getElementById("moves").textContent = "0";
        puzzleGrid.innerHTML = "";
        puzzleGrid.classList.remove("dragdrop-mode");
        tiles = [];

        const img = new Image();
        img.onload = () => {
          const containerWidth = Math.min(window.innerWidth - 60, 600);
          const tileSize = Math.floor(containerWidth / gridSize);
          const totalSize = tileSize * gridSize;

          puzzleGrid.style.gridTemplateColumns = `repeat(${gridSize}, ${tileSize}px)`;
          puzzleGrid.style.gridTemplateRows = `repeat(${gridSize}, ${tileSize}px)`;

          for (let i = 0; i < gridSize * gridSize; i++) {
            const tile = document.createElement("div");
            tile.className = "puzzle-piece";
            tile.dataset.currentIndex = i;
            tile.dataset.correctIndex = i;

            const row = Math.floor(i / gridSize);
            const col = i % gridSize;
            tile.style.backgroundImage = `url(${imageData})`;
            tile.style.backgroundSize = `${totalSize}px ${totalSize}px`;
            tile.style.backgroundPosition = `-${col * tileSize}px -${
              row * tileSize
            }px`;

            // Gestion tactile am√©lior√©e
            tile.addEventListener("touchstart", handleTouchStart, {
              passive: false,
            });
            tile.addEventListener("touchend", handleTouchEnd, {
              passive: false,
            });
            tile.addEventListener("click", () =>
              handleTileClick(parseInt(tile.dataset.currentIndex))
            );

            puzzleGrid.appendChild(tile);
            tiles.push(tile);
          }

          // Choisir une case al√©atoire comme case vide
          emptyIndex = Math.floor(Math.random() * (gridSize * gridSize));
          tiles[emptyIndex].classList.add("empty");
          tiles[emptyIndex].style.backgroundImage = "";

          updateMovableTiles();
          shuffle();
        };
        img.src = imageData;
      }

      // Puzzle glisser-d√©poser (nouveau type)
      function initPuzzleDragDrop() {
        moves = 0;
        document.getElementById("moves").textContent = "0";
        puzzleGrid.innerHTML = "";
        puzzleGrid.classList.add("dragdrop-mode");
        tiles = [];

        const img = new Image();
        img.onload = () => {
          const containerWidth = Math.min(window.innerWidth - 60, 600);
          const tileSize = Math.floor(containerWidth / gridSize);
          const totalSize = tileSize * gridSize;

          puzzleGrid.style.gridTemplateColumns = `repeat(${gridSize}, ${tileSize}px)`;
          puzzleGrid.style.gridTemplateRows = `repeat(${gridSize}, ${tileSize}px)`;
          puzzleGrid.style.position = "relative";
          puzzleGrid.style.width = `${tileSize * gridSize}px`;
          puzzleGrid.style.height = `${tileSize * gridSize}px`;

          // Cr√©er toutes les pi√®ces
          const pieces = [];
          for (let i = 0; i < gridSize * gridSize; i++) {
            const row = Math.floor(i / gridSize);
            const col = i % gridSize;

            const tile = document.createElement("div");
            tile.className = "puzzle-piece draggable dragdrop-piece";
            tile.dataset.pieceIndex = i;
            tile.dataset.correctIndex = i;
            tile.draggable = true;

            tile.style.backgroundImage = `url(${imageData})`;
            tile.style.backgroundSize = `${totalSize}px ${totalSize}px`;
            tile.style.backgroundPosition = `-${col * tileSize}px -${
              row * tileSize
            }px`;
            tile.style.width = `${tileSize}px`;
            tile.style.height = `${tileSize}px`;
            tile.style.left = `${col * tileSize}px`;
            tile.style.top = `${row * tileSize}px`;

            // √âv√©nements drag and drop
            tile.addEventListener("dragstart", handleDragStart);
            tile.addEventListener("dragend", handleDragEnd);
            tile.addEventListener("dragover", handleDragOver);
            tile.addEventListener("drop", handleDrop);
            tile.addEventListener("dragenter", handleDragEnter);
            tile.addEventListener("dragleave", handleDragLeave);

            // Support tactile pour mobile
            tile.addEventListener("touchstart", handleTouchStartDrag, {
              passive: false,
            });
            tile.addEventListener("touchmove", handleTouchMoveDrag, {
              passive: false,
            });
            tile.addEventListener("touchend", handleTouchEndDrag, {
              passive: false,
            });

            puzzleGrid.appendChild(tile);
            pieces.push(tile);
            tiles.push(tile);
          }

          // M√©langer les positions
          shuffleDragDrop();
        };
        img.src = imageData;
      }

      // Fonctions drag and drop
      function handleDragStart(e) {
        draggedElement = e.target;
        e.target.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/html", e.target.outerHTML);
      }

      function handleDragEnd(e) {
        e.target.classList.remove("dragging");
        // Retirer la classe drop-zone de toutes les pi√®ces
        tiles.forEach((tile) => tile.classList.remove("drop-zone"));
      }

      function handleDragOver(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        e.dataTransfer.dropEffect = "move";
        return false;
      }

      function handleDragEnter(e) {
        if (
          e.target !== draggedElement &&
          e.target.classList.contains("puzzle-piece")
        ) {
          e.target.classList.add("drop-zone");
        }
      }

      function handleDragLeave(e) {
        e.target.classList.remove("drop-zone");
      }

      function handleDrop(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        }

        if (
          draggedElement !== e.target &&
          e.target.classList.contains("puzzle-piece")
        ) {
          // √âchanger les positions
          swapPiecesDragDrop(draggedElement, e.target);

          moves++;
          document.getElementById("moves").textContent = moves;

          if (!startTime) {
            startTimer();
          }

          if (checkWinDragDrop()) {
            setTimeout(showVictory, 400);
          }
        }

        e.target.classList.remove("drop-zone");
        draggedElement = null;
        return false;
      }

      // Support tactile pour drag and drop sur mobile
      let touchDragStartX = 0;
      let touchDragStartY = 0;
      let touchDragElement = null;

      function handleTouchStartDrag(e) {
        e.preventDefault();
        const touch = e.touches[0];
        touchDragStartX = touch.clientX;
        touchDragStartY = touch.clientY;
        touchDragElement = e.target;
        touchDragElement.style.transition = "none";
      }

      function handleTouchMoveDrag(e) {
        if (!touchDragElement) return;
        e.preventDefault();
        const touch = e.touches[0];
        const deltaX = touch.clientX - touchDragStartX;
        const deltaY = touch.clientY - touchDragStartY;

        const rect = touchDragElement.getBoundingClientRect();
        const gridRect = puzzleGrid.getBoundingClientRect();

        touchDragElement.style.position = "fixed";
        touchDragElement.style.left = rect.left + deltaX + "px";
        touchDragElement.style.top = rect.top + deltaY + "px";
        touchDragElement.style.zIndex = "1000";
        touchDragElement.style.opacity = "0.7";

        // Trouver la pi√®ce sous le doigt
        const elementBelow = document.elementFromPoint(
          touch.clientX,
          touch.clientY
        );
        tiles.forEach((tile) => tile.classList.remove("drop-zone"));
        if (
          elementBelow &&
          elementBelow.classList.contains("puzzle-piece") &&
          elementBelow !== touchDragElement
        ) {
          elementBelow.classList.add("drop-zone");
        }
      }

      function handleTouchEndDrag(e) {
        if (!touchDragElement) return;
        e.preventDefault();

        const touch = e.changedTouches[0];
        const elementBelow = document.elementFromPoint(
          touch.clientX,
          touch.clientY
        );

        if (
          elementBelow &&
          elementBelow.classList.contains("puzzle-piece") &&
          elementBelow !== touchDragElement
        ) {
          swapPiecesDragDrop(touchDragElement, elementBelow);

          moves++;
          document.getElementById("moves").textContent = moves;

          if (!startTime) {
            startTimer();
          }

          if (checkWinDragDrop()) {
            setTimeout(showVictory, 400);
          }
        } else {
          // Remettre la pi√®ce √† sa place
          const tileSize = parseInt(touchDragElement.style.width);
          const currentIndex = parseInt(touchDragElement.dataset.pieceIndex);
          const row = Math.floor(currentIndex / gridSize);
          const col = currentIndex % gridSize;
          touchDragElement.style.left = `${col * tileSize}px`;
          touchDragElement.style.top = `${row * tileSize}px`;
        }

        touchDragElement.style.position = "absolute";
        touchDragElement.style.zIndex = "1";
        touchDragElement.style.opacity = "1";
        touchDragElement.style.transition = "transform 0.2s ease";
        tiles.forEach((tile) => tile.classList.remove("drop-zone"));

        touchDragElement = null;
      }

      // √âchanger deux pi√®ces dans le puzzle drag and drop
      function swapPiecesDragDrop(piece1, piece2) {
        const tileSize = parseInt(piece1.style.width);

        // R√©cup√©rer les positions actuelles des pi√®ces
        const pos1 = parseInt(piece1.dataset.pieceIndex);
        const pos2 = parseInt(piece2.dataset.pieceIndex);

        // Calculer les nouvelles positions visuelles
        const row1 = Math.floor(pos2 / gridSize);
        const col1 = pos2 % gridSize;
        const row2 = Math.floor(pos1 / gridSize);
        const col2 = pos1 % gridSize;

        // √âchanger les positions visuelles
        piece1.style.left = `${col1 * tileSize}px`;
        piece1.style.top = `${row1 * tileSize}px`;
        piece2.style.left = `${col2 * tileSize}px`;
        piece2.style.top = `${row2 * tileSize}px`;

        // √âchanger les indices pieceIndex (position actuelle)
        piece1.dataset.pieceIndex = pos2;
        piece2.dataset.pieceIndex = pos1;
      }

      // M√©langer le puzzle drag and drop
      function shuffleDragDrop() {
        if (tiles.length === 0) return;

        const tileSize = parseInt(tiles[0].style.width);
        const totalPieces = tiles.length;

        // M√©langer les indices (positions)
        const positions = Array.from({ length: totalPieces }, (_, i) => i);
        for (let i = positions.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [positions[i], positions[j]] = [positions[j], positions[i]];
        }

        // Appliquer les nouvelles positions
        tiles.forEach((tile, i) => {
          const newPosition = positions[i];
          const row = Math.floor(newPosition / gridSize);
          const col = newPosition % gridSize;

          tile.style.left = `${col * tileSize}px`;
          tile.style.top = `${row * tileSize}px`;
          tile.dataset.pieceIndex = newPosition;
        });

        moves = 0;
        document.getElementById("moves").textContent = "0";
      }

      // Fonctions pour le puzzle glissant
      function handleTouchStart(e) {
        if (puzzleType === "dragdrop") return; // Ne pas interf√©rer avec le drag drop
        e.preventDefault();
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }

      function handleTouchEnd(e) {
        e.preventDefault();
        if (!touchStartX || !touchStartY) return;

        const touch = e.changedTouches[0];
        const deltaX = touch.clientX - touchStartX;
        const deltaY = touch.clientY - touchStartY;
        const threshold = 10;

        const target = e.target;
        const index = parseInt(target.dataset.currentIndex);

        if (Math.abs(deltaX) < threshold && Math.abs(deltaY) < threshold) {
          // Tap simple
          handleTileClick(index);
        } else {
          // Swipe d√©tect√©
          if (Math.abs(deltaX) > Math.abs(deltaY)) {
            // Swipe horizontal
            if (deltaX > threshold && canMove(index)) {
              handleTileClick(index);
            }
          } else {
            // Swipe vertical
            if (Math.abs(deltaY) > threshold && canMove(index)) {
              handleTileClick(index);
            }
          }
        }

        touchStartX = null;
        touchStartY = null;
      }

      function handleTileClick(index) {
        if (canMove(index)) {
          moveTile(index);
        }
      }

      function canMove(index) {
        const row = Math.floor(index / gridSize);
        const col = index % gridSize;
        const emptyRow = Math.floor(emptyIndex / gridSize);
        const emptyCol = emptyIndex % gridSize;

        return (
          (Math.abs(row - emptyRow) === 1 && col === emptyCol) ||
          (Math.abs(col - emptyCol) === 1 && row === emptyRow)
        );
      }

      function updateMovableTiles() {
        tiles.forEach((tile, index) => {
          if (canMove(index) && !tile.classList.contains("empty")) {
            tile.classList.add("can-move");
          } else {
            tile.classList.remove("can-move");
          }
        });
      }

      function moveTile(index) {
        // √âchanger visuellement
        const tempBg = tiles[index].style.backgroundImage;
        const tempPos = tiles[index].style.backgroundPosition;
        const tempClass = tiles[index].className;
        const tempCorrect = tiles[index].dataset.correctIndex;

        tiles[index].style.backgroundImage =
          tiles[emptyIndex].style.backgroundImage;
        tiles[index].style.backgroundPosition =
          tiles[emptyIndex].style.backgroundPosition;
        tiles[index].className = tiles[emptyIndex].className;
        tiles[index].dataset.correctIndex =
          tiles[emptyIndex].dataset.correctIndex;

        tiles[emptyIndex].style.backgroundImage = tempBg;
        tiles[emptyIndex].style.backgroundPosition = tempPos;
        tiles[emptyIndex].className = tempClass;
        tiles[emptyIndex].dataset.correctIndex = tempCorrect;

        emptyIndex = index;
        moves++;
        document.getElementById("moves").textContent = moves;

        updateMovableTiles();

        if (checkWin()) {
          setTimeout(showVictory, 400);
        }
      }

      function shuffle() {
        let shuffleMoves = gridSize * gridSize * 50;
        for (let i = 0; i < shuffleMoves; i++) {
          const possibleMoves = [];
          for (let j = 0; j < tiles.length; j++) {
            if (canMove(j)) possibleMoves.push(j);
          }
          const randomMove =
            possibleMoves[Math.floor(Math.random() * possibleMoves.length)];

          // Swap sans incr√©menter moves
          const tempBg = tiles[randomMove].style.backgroundImage;
          const tempPos = tiles[randomMove].style.backgroundPosition;
          const tempClass = tiles[randomMove].className;
          const tempCorrect = tiles[randomMove].dataset.correctIndex;

          tiles[randomMove].style.backgroundImage =
            tiles[emptyIndex].style.backgroundImage;
          tiles[randomMove].style.backgroundPosition =
            tiles[emptyIndex].style.backgroundPosition;
          tiles[randomMove].className = tiles[emptyIndex].className;
          tiles[randomMove].dataset.correctIndex =
            tiles[emptyIndex].dataset.correctIndex;

          tiles[emptyIndex].style.backgroundImage = tempBg;
          tiles[emptyIndex].style.backgroundPosition = tempPos;
          tiles[emptyIndex].className = tempClass;
          tiles[emptyIndex].dataset.correctIndex = tempCorrect;

          emptyIndex = randomMove;
        }

        moves = 0;
        document.getElementById("moves").textContent = "0";
        updateMovableTiles();
      }

      function checkWin() {
        if (puzzleType === "dragdrop") {
          return checkWinDragDrop();
        }

        // Pour le puzzle glissant
        for (let i = 0; i < tiles.length; i++) {
          if (parseInt(tiles[i].dataset.correctIndex) !== i) {
            return false;
          }
        }
        return true;
      }

      // V√©rifier la victoire pour le puzzle drag and drop
      function checkWinDragDrop() {
        for (let i = 0; i < tiles.length; i++) {
          const pieceIndex = parseInt(tiles[i].dataset.pieceIndex);
          const correctIndex = parseInt(tiles[i].dataset.correctIndex);
          if (pieceIndex !== correctIndex) {
            return false;
          }
        }
        // Toutes les pi√®ces sont √† la bonne place
        isSolved = true;
        stopTimer();
        return true;
      }

      function showVictory() {
        stopTimer();

        // Afficher l'image compl√®te seulement √† la victoire
        document.getElementById("victoryImage").src = imageData;
        document.getElementById("victoryMessage").textContent = customMessage;
        document.getElementById(
          "victoryStats"
        ).innerHTML = `Temps: ${formatTime(timer)} | Coups: ${moves}`;

        document.getElementById("victoryOverlay").style.display = "flex";

        // Feux d'artifice
        for (let i = 0; i < 50; i++) {
          setTimeout(() => createFirework(), i * 100);
        }
      }

      function createFirework() {
        const x = Math.random() * window.innerWidth;
        const y = Math.random() * window.innerHeight * 0.5;
        const colors = [
          "#ffd700",
          "#ff6b6b",
          "#4ecdc4",
          "#45b7d1",
          "#f8b500",
          "#ff1744",
        ];

        for (let i = 0; i < 30; i++) {
          const particle = document.createElement("div");
          particle.className = "firework";
          particle.style.left = x + "px";
          particle.style.top = y + "px";
          particle.style.background =
            colors[Math.floor(Math.random() * colors.length)];

          const angle = (Math.PI * 2 * i) / 30;
          const velocity = 50 + Math.random() * 100;
          particle.style.setProperty("--x", Math.cos(angle) * velocity + "px");
          particle.style.setProperty("--y", Math.sin(angle) * velocity + "px");

          document.body.appendChild(particle);
          setTimeout(() => particle.remove(), 1000);
        }
      }

      function startTimer() {
        timer = 0;
        startTime = Date.now();
        timerInterval = setInterval(() => {
          timer = Math.floor((Date.now() - startTime) / 1000);
          document.getElementById("timer").textContent = formatTime(timer);
        }, 1000);
      }

      function stopTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      }

      document.getElementById("shuffleBtn").addEventListener("click", () => {
        if (puzzleType === "dragdrop") {
          shuffleDragDrop();
        } else {
          shuffle();
        }
        stopTimer();
        startTimer();
      });

      document.getElementById("resetBtn").addEventListener("click", () => {
        initPuzzle();
        stopTimer();
        startTimer();
      });

      function copyUrl() {
        // Utiliser l'URL compl√®te stock√©e dans la variable plut√¥t que le champ input
        // (le champ input peut √™tre tronqu√© par le navigateur)
        const urlToCopy =
          shareUrlComplete || document.getElementById("shareUrl").value;

        console.log("Copie de l'URL, longueur:", urlToCopy.length);

        if (navigator.clipboard) {
          navigator.clipboard
            .writeText(urlToCopy)
            .then(() => {
              alert(
                "‚úÖ Lien copi√© dans le presse-papier ! (" +
                  urlToCopy.length +
                  " caract√®res)"
              );
            })
            .catch((err) => {
              console.error("Erreur lors de la copie:", err);
              // Fallback: essayer avec le champ input
              const urlInput = document.getElementById("shareUrl");
              urlInput.select();
              urlInput.setSelectionRange(0, 99999);
              document.execCommand("copy");
              alert("‚úÖ Lien copi√© dans le presse-papier !");
            });
        } else {
          // Fallback: cr√©er un √©l√©ment textarea temporaire pour copier
          const textarea = document.createElement("textarea");
          textarea.value = urlToCopy;
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          document.body.appendChild(textarea);
          textarea.select();
          textarea.setSelectionRange(0, 99999);
          try {
            document.execCommand("copy");
            alert(
              "‚úÖ Lien copi√© dans le presse-papier ! (" +
                urlToCopy.length +
                " caract√®res)"
            );
          } catch (err) {
            console.error("Erreur lors de la copie:", err);
            alert(
              "‚ùå Erreur lors de la copie. Veuillez s√©lectionner et copier manuellement."
            );
          }
          document.body.removeChild(textarea);
        }
      }

      function shareNative() {
        // Utiliser l'URL compl√®te stock√©e dans la variable
        const url =
          shareUrlComplete || document.getElementById("shareUrl").value;
        if (navigator.share) {
          navigator
            .share({
              title: "Puzzle de No√´l üéÑ",
              text: customMessage || "Venez jouer √† ce puzzle de No√´l !",
              url: url,
            })
            .catch(() => {
              copyUrl();
            });
        } else {
          copyUrl();
        }
      }

      // Retourner √† l'accueil
      function returnHome() {
        // R√©initialiser toutes les variables
        imageData = null;
        customMessage = "";
        moves = 0;
        timer = 0;
        puzzleType = "sliding";
        shareUrlComplete = null;
        stopTimer();

        // R√©initialiser l'interface
        step1.style.display = "block";
        step2.style.display = "none";
        puzzleArea.style.display = "none";
        shareSection.style.display = "none";

        // R√©initialiser les champs
        document.getElementById("imageInput").value = "";
        document.getElementById("imagePreview").innerHTML = "";
        document.getElementById("messageInput").value =
          "üéÑ F√©licitations ! Puzzle r√©solu ! üéÅ";
        document.getElementById("gridSize").value = "4";
        document.getElementById("puzzleType").value = "sliding";
        document.getElementById("passwordInput").value = "";
        storedPasswordHash = null;

        // Remettre le titre original
        document.querySelector("h1").textContent = "üéÑ Puzzle de No√´l üéÅ";

        // Nettoyer l'URL (retirer le hash)
        if (window.location.hash) {
          window.history.replaceState(null, null, window.location.pathname);
        }
      }

      // Pr√©venir le zoom sur double-tap
      let lastTouchEnd = 0;
      document.addEventListener(
        "touchend",
        (e) => {
          const now = Date.now();
          if (now - lastTouchEnd <= 300) {
            e.preventDefault();
          }
          lastTouchEnd = now;
        },
        false
      );
    </script>
  </body>
</html>
